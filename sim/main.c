/**
 * @file main.c
 * @brief LVGL Simulator for GaggiMate Display
 * 
 * This file provides a web-based simulator for the GaggiMate display UI
 * allowing testing of UI changes before deploying to hardware.
 */

#include "lvgl.h"
#include <emscripten.h>
#include <SDL2/SDL.h>
#include <stdio.h>
#include <time.h>

// Controller stub for UI
typedef struct {
    int dummy;
} Controller;

Controller controller = {0};

// Display dimensions - matching LilyGo T-RGB
#define DISP_HOR_RES 480
#define DISP_VER_RES 480

// LVGL objects
static lv_disp_draw_buf_t disp_buf;
static lv_disp_drv_t disp_drv;
static lv_indev_drv_t indev_drv;
static lv_color_t *buf1;
static lv_color_t *buf2;

// SDL objects
static SDL_Window *window;
static SDL_Renderer *renderer;
static SDL_Texture *texture;

// Mouse state
static int mouse_x = 0;
static int mouse_y = 0;
static bool mouse_pressed = false;

// Include UI (generated by SquareLine Studio)
#include "ui.h"

// Forward declarations
static void hal_init(void);
static void monitor_sdl_refr_task(void);
static void sdl_display_flush(lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p);
static void sdl_mouse_read(lv_indev_drv_t *indev_drv, lv_indev_data_t *data);
static void transition_cb(lv_timer_t *t);

/**
 * Initialize hardware abstraction layer (SDL)
 */
static void hal_init(void) {
    // Initialize SDL
    if (SDL_Init(SDL_INIT_VIDEO) != 0) {
        printf("SDL_Init Error: %s\n", SDL_GetError());
        return;
    }

    // Create window
    window = SDL_CreateWindow("GaggiMate Display Simulator",
                              SDL_WINDOWPOS_UNDEFINED,
                              SDL_WINDOWPOS_UNDEFINED,
                              DISP_HOR_RES, DISP_VER_RES,
                              SDL_WINDOW_SHOWN);
    if (!window) {
        printf("SDL_CreateWindow Error: %s\n", SDL_GetError());
        SDL_Quit();
        return;
    }

    // Create renderer
    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    if (!renderer) {
        printf("SDL_CreateRenderer Error: %s\n", SDL_GetError());
        SDL_DestroyWindow(window);
        SDL_Quit();
        return;
    }

    // Create texture for rendering
    texture = SDL_CreateTexture(renderer,
                                SDL_PIXELFORMAT_RGB565,
                                SDL_TEXTUREACCESS_STREAMING,
                                DISP_HOR_RES, DISP_VER_RES);
    if (!texture) {
        printf("SDL_CreateTexture Error: %s\n", SDL_GetError());
        SDL_DestroyRenderer(renderer);
        SDL_DestroyWindow(window);
        SDL_Quit();
        return;
    }

    SDL_SetTextureBlendMode(texture, SDL_BLENDMODE_BLEND);

    // Allocate LVGL buffers
    buf1 = (lv_color_t *)malloc(DISP_HOR_RES * DISP_VER_RES * sizeof(lv_color_t));
    buf2 = (lv_color_t *)malloc(DISP_HOR_RES * DISP_VER_RES * sizeof(lv_color_t));

    if (!buf1 || !buf2) {
        printf("Failed to allocate LVGL buffers\n");
        return;
    }
}

/**
 * Flush the display buffer to SDL
 */
static void sdl_display_flush(lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p) {
    lv_coord_t hres = disp_drv->hor_res;
    lv_coord_t vres = disp_drv->ver_res;

    // Update texture with new data
    uint16_t *pixels;
    int pitch;
    
    if (SDL_LockTexture(texture, NULL, (void **)&pixels, &pitch) == 0) {
        lv_coord_t y;
        for (y = area->y1; y <= area->y2; y++) {
            lv_coord_t x;
            for (x = area->x1; x <= area->x2; x++) {
                pixels[y * DISP_HOR_RES + x] = color_p->full;
                color_p++;
            }
        }
        SDL_UnlockTexture(texture);
    }

    lv_disp_flush_ready(disp_drv);
}

/**
 * Read mouse/touch input
 */
static void sdl_mouse_read(lv_indev_drv_t *indev_drv, lv_indev_data_t *data) {
    data->point.x = mouse_x;
    data->point.y = mouse_y;
    data->state = mouse_pressed ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;
}

/**
 * SDL refresh and event handling
 */
static void monitor_sdl_refr_task(void) {
    SDL_Event event;
    
    while (SDL_PollEvent(&event)) {
        switch (event.type) {
            case SDL_MOUSEMOTION:
                mouse_x = event.motion.x;
                mouse_y = event.motion.y;
                break;
                
            case SDL_MOUSEBUTTONDOWN:
                if (event.button.button == SDL_BUTTON_LEFT) {
                    mouse_pressed = true;
                }
                break;
                
            case SDL_MOUSEBUTTONUP:
                if (event.button.button == SDL_BUTTON_LEFT) {
                    mouse_pressed = false;
                }
                break;
                
            case SDL_QUIT:
                emscripten_cancel_main_loop();
                break;
        }
    }

    // Render the texture
    SDL_RenderClear(renderer);
    SDL_RenderCopy(renderer, texture, NULL, NULL);
    SDL_RenderPresent(renderer);
}

/**
 * Create a simple demo UI if ui_init is not available
 */
static void create_demo_ui(void) {
    lv_obj_t *label = lv_label_create(lv_scr_act());
    lv_label_set_text(label, "GaggiMate Display Simulator\n\n"
                             "UI files will be loaded here.\n\n"
                             "To use the actual UI:\n"
                             "1. Link the src/display/ui files\n"
                             "2. Include necessary assets\n"
                             "3. Call ui_init()");
    lv_obj_center(label);
    lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, 0);
}

/**
 * Main loop iteration
 */
static void main_loop(void) {
    monitor_sdl_refr_task();
    lv_timer_handler();
}

/**
 * Main entry point
 */
int main(int argc, char **argv) {
    printf("GaggiMate Display Simulator Starting...\n");
    printf("Display resolution: %dx%d\n", DISP_HOR_RES, DISP_VER_RES);
    
    // Initialize HAL (SDL)
    hal_init();
    
    // Initialize LVGL
    lv_init();
    
    // Initialize display buffer
    lv_disp_draw_buf_init(&disp_buf, buf1, buf2, DISP_HOR_RES * DISP_VER_RES);
    
    // Initialize display driver
    lv_disp_drv_init(&disp_drv);
    disp_drv.hor_res = DISP_HOR_RES;
    disp_drv.ver_res = DISP_VER_RES;
    disp_drv.flush_cb = sdl_display_flush;
    disp_drv.draw_buf = &disp_buf;
    lv_disp_drv_register(&disp_drv);
    
    // Initialize input device driver
    lv_indev_drv_init(&indev_drv);
    indev_drv.type = LV_INDEV_TYPE_POINTER;
    indev_drv.read_cb = sdl_mouse_read;
    lv_indev_drv_register(&indev_drv);
    
    printf("LVGL initialized\n");
    
    // Initialize UI
    ui_init();
    
    printf("UI initialized\n");
    printf("Simulator ready. Click and drag to simulate touch.\n");

    // Pre-initialize all screens so pointers are valid for navigation
    extern void ui_StandbyScreen_screen_init(void);
    extern void ui_BrewScreen_screen_init(void);
    extern void ui_GrindScreen_screen_init(void);
    extern void ui_MenuScreen_screen_init(void);
    extern void ui_ProfileScreen_screen_init(void);
    extern void ui_StatusScreen_screen_init(void);
    extern void ui_SimpleProcessScreen_screen_init(void);

    ui_StandbyScreen_screen_init();
    ui_BrewScreen_screen_init();
    ui_GrindScreen_screen_init();
    ui_MenuScreen_screen_init();
    ui_ProfileScreen_screen_init();
    ui_StatusScreen_screen_init();
    ui_SimpleProcessScreen_screen_init();

    // Ensure initial screen transitions from Init to Standby after 2 seconds
    extern lv_obj_t *ui_StandbyScreen;
    extern lv_obj_t *ui_InitScreen;
    lv_timer_t *transition_timer = lv_timer_create(transition_cb, 2000, NULL);
    lv_timer_set_repeat_count(transition_timer, 1);
    
    // Start main loop
    emscripten_set_main_loop(main_loop, 0, 1);
    
    return 0;
}

static void transition_cb(lv_timer_t *t) {
    (void)t;
    extern lv_obj_t *ui_StandbyScreen;
    extern lv_obj_t *ui_InitScreen;
    if (lv_scr_act() == ui_InitScreen && ui_StandbyScreen) {
        lv_scr_load(ui_StandbyScreen);
        printf("[SIM] Auto-transition: Init -> Standby\n");
    }
}
